"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.watch = exports.generate = exports.shouldRegenerate = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const engines_1 = require("@prisma/engines");
const internals_1 = require("@prisma/internals");
const chokidar_1 = __importDefault(require("chokidar"));
async function shouldRegenerate(output, lastModifiedAt = Date.now()) {
    if (!output) {
        return true;
    }
    let lastGenerateAt = 0;
    try {
        const state = await node_fs_1.default.promises.stat(node_path_1.default.resolve(output, 'index.js'));
        lastGenerateAt = state.mtimeMs;
    }
    catch {
        lastGenerateAt = 0;
    }
    return lastGenerateAt < lastModifiedAt;
}
exports.shouldRegenerate = shouldRegenerate;
async function generate(entry, logger, lastModifiedAt = Date.now()) {
    try {
        logger.info('begin to generate');
        const generators = await (0, internals_1.getGenerators)({
            schemaPath: entry,
            printDownloadProgress: true,
            version: engines_1.enginesVersion,
            // cliVersion: '5.5.2',
            generatorNames: undefined,
            postinstall: false,
            noEngine: false
        });
        if (!generators.length) {
            throw new Error('no generators');
        }
        let count = 0;
        for (const generator of generators) {
            const output = generator.config.output?.value;
            if (await shouldRegenerate(output, lastModifiedAt)) {
                try {
                    count++;
                    await generator.generate();
                    generator.stop();
                }
                catch (err) {
                    generator.stop();
                }
            }
        }
        if (count > 0) {
            logger.info('generated');
        }
        else {
            logger.info('no need to generate');
        }
    }
    catch (err) {
        logger.error(err);
        throw err;
    }
}
exports.generate = generate;
function watch(entry, logger, cb) {
    let watcher;
    const watching = new Promise((resolve, reject) => {
        let timer;
        let lastModifiedAt = 0;
        watcher = chokidar_1.default.watch(entry);
        watcher.on('ready', () => {
            const watched = watcher.getWatched();
            for (const files of Object.values(watched)) {
                if (files.length) {
                    return;
                }
            }
            resolve(0);
            cb?.();
        });
        watcher.on('all', (ev, p, stats) => {
            lastModifiedAt = Math.max(lastModifiedAt, stats?.mtimeMs || Date.now());
            timer && clearTimeout(timer);
            timer = setTimeout(() => {
                timer = undefined;
                generate(entry, logger, lastModifiedAt).then(() => {
                    resolve(0);
                    cb?.();
                }, err => {
                    reject(err);
                    cb?.(err);
                });
            }, 300);
        });
    });
    return {
        watching,
        unwatch: () => watcher.close()
    };
}
exports.watch = watch;
//# sourceMappingURL=generator.js.map